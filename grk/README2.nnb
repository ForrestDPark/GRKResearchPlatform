{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# Chapter 13 웹소켓을 사용한 실시간 채팅 구현 \n\n- 웹소켓은 서버도 클라이언트의 요청없이 응답을 줄 수 있음. \ngrk 플랫폼 내부 채팅기능은 어디에서 사용되어야 하는가?\n- project? task? project 내부에서만 채팅이 이루어지도록 해볼까? \n\n# 13.1 웹소켓 소개 \n\n폴링 방식 : 주기적으로 요청을 보내서 응답을 받음\n롱폴링 방식 : 클라이언트와 서버간의 커넥션을 유지한 상태로 응답을 주고 받는 방식 \n요청한 데이터에 변화가 있을떄 응답을 보냄. \n롱폴링은 요청을 보낸후 응답 대기 후 응답이 옴ㄴ 바로 다시 요청을 보냄. \n\n웹소켓\n- 하나의 tcp 커넥션으로 서버와 클라이언트간에 양방향 통신을 할 수 있게 만든 프로토콜 \n- 대부분의 웹브라우저에서 안정적으로 사용. (IE9 오래된 웹브라우저는 지원불가)\n- 실시간 네트워킹 구현에 용이함. \n\n## 13.1.1 웹소켓의 동작 방법 \n핸드 쉐이크 : 서버와 클라이언트가 커넥션을 맺는 과정, 최초 한번만 일어남. HTTP 1.1 프로토콜을 사용하고 헤더에 Upgrade: websocket 과 Connection : Upgrade 를 추가해 웹소켓 프로토콜 사용 하도록 함. \n\n데이터 전송 : \n\n\n### (1) 핸드쉐이크 \n> 핸드 쉐이크 요청 \n```ts\nGET /chat HTTP/1.1 // 핸드 쉐이킹은 GET 으로 보내야함. \nHost: server.example.com\nUpgrade: websocket // 현재 프로토콜에서 다른 프로토콜로 업그레이드하는 규칙\nConnection: Upgrade //Upgrade filed 가 있으면 명시\nSec-WebSocket-Key: dgh~ // 클라이언트 키 \nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\n\n// 클라이언트가 요청하는 하위 프로토콜 \nSec-WebSocket-Version\n```\n\n> 핸드쉐이크 응답\n```ts\nHTTP/1.1 101 Switching Protocols // 프로토콜 전환 되어 연결 잘됨 \nUpgrade: websocket\nConnection : Upgrade\n//클라이언트로부터 받은 키를 사용해 계산된 값\nSec-WebSocket-Accept: ~~\nSec-WebSocket-Protocol: chat\n```\n- 핸드쉐이크 완료시 http 에서 ws 로 https 면 wss 로 변경 됨 \n\n\n### (2)  2단계 데이터 전송 \n1. 데이터는 message 라 부름. \n2. 메시지는 프레임(frame) 의 모음 \n3. 프레임은 바이트의 배열이며 다음과 같은 형태를 가짐\n<img src=\"https://blog.kakaocdn.net/dn/bybCgi/btsL4IrHLdw/iHKDWLbzwTqhLt7yfb9lH1/img.webp\" data-mce-src=\"https://blog.kakaocdn.net/dn/bybCgi/btsL4IrHLdw/iHKDWLbzwTqhLt7yfb9lH1/img.webp\" data-origin-width=\"1162\" data-origin-height=\"686\" data-is-animation=\"false\" width=\"750\" height=\"443\">\n\n- 프레임은 헤더와 페이로드(Payload) 로 이루어짐 \n- 헤더에는 FIN, RSV1~3, 오프코드(opcode) , 마스크(MASK) ,payload 길이 , 마스킹 키 가 있음. \n\nFIN: 1(마지막), 0(데이터 더있음.)\nopcode(payload type): \n    {\n        0001: text,\n        0010 : 바이너리,\n        1000: 커넥션 끊는다!\n        1001: ping(클라이언트가 ping 을 날림)\n        1010: pong(서버가 pong 으로 응답. )\n    }\n\n### (3) 3단계 : 접속을 끊음. opcode: 1000\n\n- 웹소켓은 데이터를 전송하는것만 지원. \n- 채팅방 만들기, 채팅방 전체 사람들에게 메세지 발송, 접속끊어진경우 자동 연결 등 soket.io 가 이런부분을 지원해줌. \n\n\n\n\n\n\n\n# 13.3 간단한 채팅 어플리케이션 nest js 만들기 \n> 순서\n> 1. 프로젝트 생성및 패키지 설치\n> 2. 정적 파일 서비스를 위한 main.ts 설정 \n> 3. socket.io 서버 구동을 위한 게이트 웨이 만들기 \n> 4. 클라이언트 측 코드 작성(index.html)\n> 5. test\n\n## 13.3.1 socket io 프로젝트 생성 \n\n### (1) nest cli 를 통한 디렉토리 \n```bash\ncd grk/src\n\nnest g module events\nnest g gateway events \n\n\nnpm i @nestjs/websockets @nestjs/platform-socket.io\nnpm i -D @types/socket.io\n\n```\n\n### (2) html 파일 불러오도록 main ts 설정 \n> main.ts \n```ts\n// Static Asset 설정\nimport { NestExpressApplication } from '@nestjs/platform-express';\n  // HTML form 파일을 제공할 staticAsset \n  app.useStaticAssets(join(__dirname,'..','static'))\n  \n```\n- NestExpressApplication 에는 useStaticAssets 메서드가 있음. \n- static 폴더를 정적 파일 경로로 지정. \n\n### (3) index.html 파일 생성 \n> grk/static/index.html\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>GRK Research Project Chat Room</title>\n    </head>\n    <body>\n        <div id=\"chat\">GRK Chat</div>\n    </body>\n</html>\n```\n\n## 13.3.4 서버측 작업을 위한 게이트 웨이 생성 \n\n- 게이트 웨이 사용시 의존성주입, 데코레이터, 필터, 가드 등의 NestJS 기능을 사용가능,. 프로토콜이 http 라면 컨트롤러로 부터 요청을 받고 프로토콜이 ws 라면 게이트웨이로 부터 요청을 받음. 진입점의 차이가 다르며 사용한느 데코레이터가 달라짐. \n- 게이트웨이는 웹소켓용 컨트롤러.. \n<img src=\"https://blog.kakaocdn.net/dn/wu9iC/btsL3kyLvvw/9jiLvwQ9vM2ST3KIeqKV70/img.jpg\" data-mce-src=\"https://blog.kakaocdn.net/dn/wu9iC/btsL3kyLvvw/9jiLvwQ9vM2ST3KIeqKV70/img.jpg\" data-origin-width=\"874\" data-origin-height=\"324\" data-is-animation=\"false\" width=\"747\" height=\"277\">\n\n\n- 게이트 웨이를 붙이는 법 @WebSocketGateway() 데코레이터를 클래스에 붙이면 됨. \n\nproject 에서 chat 기능 실현 \n```bash\ncd src \nnest g gateway project\n```\n> project.gateway.ts\n```ts\nimport { \n  SubscribeMessage, \n  WebSocketGateway,\n  WebSocketServer,\n\n} from '@nestjs/websockets';\n// socket io 임포트 \nimport { Server, Socket } from 'socket.io'\n\n@WebSocketGateway()\nexport class ProjectGateway {\n  \n  // 웹 소켓 서버 인ㅅ턴스 선언 \n  @WebSocketServer() server : Server\n\n  // message event 구독\n  @SubscribeMessage('message')\n  handleMessage(socket: Socket, data : any): void {\n    // 접속한 클라이언트에게 멧지 전송\n    this.server.emit('message', `client-${socket.id.substring(0,4)} : ${data}`,)\n  }\n}\n```\n- socket.io 서버 옵션중 namespace 는 자주 사용함. \n- 참고 : http://socket.io/docs/v4/server-options\n\n@WebSocketGateway() : 기본포트 3000을 사용 \n@WebSocketGateway(port)\n@WebSocketGateway(options)\n@WebSocketGateway(port,option)\n\n-> 향후 Config 사용해서 웹소켓 포트를 따로 설정해 두도록 하자. \n\n- @SubscribeMessage('message') : 'message' 라는 이벤트를 구독하는 리스너임. \n- message 이벤트로 데이터 전송시 data 인수에 데이터가 담겨있음. \n- data 는 @MessageBody() , socket 에는 @ConnectedSocket() 데코가 필요함. -> @SubscribeMessage 데코에서는 기본 세팅 됨. \n- 웹 소켓 인스턴스의 emit() 메서드를 사용해 클라이언트 전체에 멤시지를 보냄. \n- 첫째 인수인 message 는 이벤트 명, 두번째인수는 보내주는 데이터 \n- socket.io 에서는 모든 클라이언트 인스턴스에 임의의 id 값을 줌. \n- id 에는 무작위 문자열이 저장되어 있음. \n\n## 13.3.5 게이트웨이를 모듈에 등록. \n\n\n> project.module.ts\n```ts\n// 웹소켓 체팅을 한임포트 \nimport { ProjectGateway } from './project.gateway';\n\n    providers: [\n        ProjectService, ProjectMongoRepository,\n        // 웹소켓 게이트 웨이 프로바이더 \n        ProjectGateway,\n\n    ],\n    exports: [ProjectService],\n})\n```\n- 게이트웨이는 컨트롤러 와 같은 개념이지만 게이트웨이는 다른 클래스에서 주입해서 사용할 수있는 프로바이더여서 모듈에 등록해야함\n\n\n## 13.3.6 클라이언트를 위한 index.html \n- 표준 프로토콜에서 브라우저 자체 웹소켓 지원. \n- socket.io 는 브라우저에서 지원 하지 않으므로 클라이언트에서 socket.io를 사용하도록 라이브러리 설정 필요 \n\n> src/static/index.html \n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>GRK Research Project Chat Room</title>\n    </head>\n    <body>\n        <h2> Simple chat</h2>\n        <div id=\"chat\">GRK Chat</div>\n\n        <input type=\"text\" id=\"message\" placeholder=\"input your message\">\n        <button onclick=\"sendMessage()\">전송</button>\n\n        \n    </body>\n    <!-- jquery 로드 -->\n    <script src = \"http://code.jquery.com/jquery-3.6.1.slim.js\"></script>\n    <!-- socket.io 클라이언트 로드  -->\n    <script src=\"http://localhost:3000/socket.io/socket.io.js\"></script>\n    <script>\n        // socket.io 인스턴스 생성 \n        const socket =io('http://localhost:3000/project/chat')\n        // 전송 버튼 클릭 시 입력된 글을 message 이벤트로 보냄 \n        function sendMessage() {\n            const message = $('#message').val()\n            socket.emit('message', message)\n            \n            $('#message').val('') // 입력창 비우기\n        }\n        socket.on('connect', () => {\n            console.log('connected')\n        })\n\n        socket.on('message',(message) => {\n            $('#chat').append(`<div>${message}</div>`)\n        })\n\n    </script>\n</html>\n\n```\n\n이후 프로젝트 모듈에 게이트웨이를 프로바이더에 추가해야하고 appmodule 에서 project 모듈을 추가해야함. !!\n\n# 결과 \n<img src=\"https://blog.kakaocdn.net/dn/bTSpBQ/btsL3mpNMfc/78flZldajzPgMxcqKfBfik/img.webp\" data-mce-src=\"https://blog.kakaocdn.net/dn/bTSpBQ/btsL3mpNMfc/78flZldajzPgMxcqKfBfik/img.webp\" data-origin-width=\"1718\" data-origin-height=\"1600\" data-is-animation=\"false\" width=\"754\" height=\"702\">\n\n\n# 13.4 채팅방기능이 있는 채팅 어플리케이션 \n- 네임스페이스는 네임스페이스로 지정된 곳에만 이벤트를 발생시킴 \n- 멀티플랙싱이라고도 함. \n- 슬랙의 워크스페이스나 게임 채널과 비슷함. \n- 네임 스페이스 안에 룸 생성가능 \n- 네임스페이스와 룸을 같이 사용하여 더 정교하게 메세지 송수신 제어가능 \n\n## 13.4.1  네임스페이스 사용 \n### (1) name space\n\n> project.gateway.ts\n\n```TS\n\nimport { \n  SubscribeMessage, \n  WebSocketGateway,\n  WebSocketServer,\n\n} from '@nestjs/websockets';\n// socket io 임포트 \nimport { Server, Socket } from 'socket.io'\n\n@WebSocketGateway({namespace:'project/chat'})\nexport class ProjectGateway {\n  // 웹 소켓 서버 인ㅅ턴스 선언 \n  @WebSocketServer() server : Server\n  \n\n  // message event 구독\n  @SubscribeMessage('message')\n  handleMessage(socket: Socket, data : any): void {\n    // 접속한 클라이언트에게 멧지 전송\n    // console.log(\"hi\")\n    this.server.emit('message', `User-${socket.id.substring(0,4)} : ${data}`,)\n  }\n}\n```\n\n## 13.4.2 닉네임 추가 \n### (1) 웹페이지 진입시 입력한 닉네임을 사용하도록 변경 \n=> 향후 username 으로 채팅하도록 변경 필요 \n> index.html\n```html\n <script>\n        // socket.io 인스턴스 생성 \n        const socket =io('http://localhost:3000/project/chat')\n\n        const nickname = prompt('input your nickname')\n\n\n        // 전송 버튼 클릭 시 입력된 글을 message 이벤트로 보냄 \n        function sendMessage() {\n            // message 창에 입력된 값 할당\n            const message = $('#message').val()\n\n            $('#chat').append(`<div> 나 : ${message}</div>`)\n\n            // 채팅 소켓의 message 로 방출 \n            socket.emit('message', {message, nickname})\n            \n            $('#message').val('') // 입력창 비우기\n        }\n        socket.on('connect', () => {\n            console.log('connected')\n        })\n\n        socket.on('message',(message) => {\n            $('#chat').append(`<div>${message}</div>`)\n        })\n\n    </script>\n```\n> project.gateway.ts\n```ts\n// message event 구독\n  @SubscribeMessage('message')\n  handleMessage(socket: Socket, data : any): void {\n    // 접속한 클라이언트에게 멧지 전송\n    // this.server.emit('message', `User-${socket.id.substring(0,4)} : ${data}`,)\n    const { message, nickname} =data\n    socket.broadcast.emit('message',`${nickname}: ${message}`)\n  }\n}\n```\n- 클ㄹ라이언트  측에서 data에 nickname 과 message 정보를 객체 형태로 전송함. 해당 데이터를 풀때 비구조화 할당 문법을 사용해서 바로 추출 가능 \n- socket.broadcast.emit()은 server.emit()과 다르게 전송을 요청한 클라이언트를 제외하고 다른 클라이언트들에게 데이터를 전송하여 채팅할 때 내 메시지와 상대방 메시지를 구분 용이함. \n\n<img src=\"https://blog.kakaocdn.net/dn/lChQI/btsL4MOlrQA/cN66tWrFKHalby2zIIw72k/img.webp\" data-mce-src=\"https://blog.kakaocdn.net/dn/lChQI/btsL4MOlrQA/cN66tWrFKHalby2zIIw72k/img.webp\" data-origin-width=\"1718\" data-origin-height=\"1600\" data-is-animation=\"false\" width=\"750\" height=\"698\">\n\n> nickname 으로 뜨게 함. \n<img src=\"https://blog.kakaocdn.net/dn/bviWfR/btsL3q6SZGb/TDoGxtBUKGKnoG8vW4Kkj1/img.webp\" data-mce-src=\"https://blog.kakaocdn.net/dn/bviWfR/btsL3q6SZGb/TDoGxtBUKGKnoG8vW4Kkj1/img.webp\" data-origin-width=\"1150\" data-origin-height=\"1038\" data-is-animation=\"false\" width=\"754\" height=\"681\">\n\n## 13.4.3 채팅방 생성하기 \n\n- socket.io 의 room 기능을 사용해 채팅방 구현 가능 \n- 채팅방 생성 및 입장 기능을 생성 \n- project.gateway.ts, project.module.ts, static/index.html, static/script.js 수정 \n\n### (1) index.html  채팅방 목록, 채팅방 추가기능 구현 \n> static/index.html \n```html\n <body>\n        <h2> GRK research project chat</h2>\n        <!-- <div id=\"chat\">GRK Chat</div> -->\n        <div>\n            <h2>채팅방 목록</h2>\n            <ul id=\"rooms\"></ul>\n        </div>\n\n        <input type=\"text\" id=\"message\" placeholder=\"input your message\">\n        <button onclick=\"sendMessage()\">전송</button>\n        <!-- 방 만들기 버튼 -->\n        <button onclick=\"createRoom()\">방 만들기</button>\n```\n- id rooms 인 곳에 li 태그로 추가 \n\n### (2) createRoom() 함수 static/script.js 추가 \n\n// src/script.js \nconst socket =io('http://localhost:3000/project/chat')\n\nconst roomSocket = io('http://localhost:3000/project/room')\n\nconst nickname = prompt('input your nickname')\n\n// 채팅방 생성 버튼 클릭 시 실행하는 함수 \nfunction createRoom() {\n    const room = prompt('input room name to create.')\n    roomSocket.emit('createRoom', { room, nickname})\n}\n\n// 클라이언트 측에서 채팅방 추가하는 함수 \nroomSocket.on(\"rooms\", (data) => {\n    console.log(data)\n    $('#rooms').empty()\n    data.forEach((room) => {\n        $('#rooms').append(`<li>${room} <button onclick=\"joinRoom('${room}')\" \n            >join</button></li>`)\n    })\n})\n\n- project/room 이라는 채팅방용 네임스페이스를 하나 더 만들어서 채팅방용 이벤트만 처리 -> 게이트웨이 클래스 하나 더 추가 필요 \n- 채팅방 생성 버튼 클릭시 실행함수 : 방이름 prompt 로 받음 . \n- rooms data 에는 채팅 방 배열이 들어 있음. \n-  ($('#rooms')).empty() :채팅방 생성될 시 서버에서 리스트 값을 새로받아오므로 비우고 다시 갱신 \n- 서버에서 받은 data 를 순회하면서 rooms 라는 id 값을 가진 html 요소에 li 태그를 사용해 추가함. \n- 기존 script  태그 안에있던 JS 코드를 모두 static/script.js 로 옮김. \n- index.html 에서 생성 버튼클릭 > createRoom() 함수 실행 > roomSocket.emit { room, nickname} 으로 데이터 전송 \n- roomSocket.on .. : 소켓 객체에서 rooms 라는 이벤트가 발생했을때 실행되는 콜백 함수 정의 \n- roomSocket 은 서버와의 웹소켓 연결을 통해 실시간으로 데이터를 주고받는 객체임. \n- (data) => {} 이벤트가 발생했을때 서버에서 보낸 data 를 가지고 실행하는 콜백함수 임. \n- $('#rooms').empty() 는 jQuery 를 사용하여  id 가 rooms 인 요소 선택후 그안의 내용 모두 지움. \n- data.forEach((room) => {}) : data 에 있는 room 들을 하나씩 순회 하여 콜백 함수 안의 내용을 실행함. \n- $('#rooms').append() : jQuery 를 사용하여 id 가 rooms 인 요소에 새로운 html 코드를 추가함. \n- ```<li>${room} <button onclick=\"joinRoom('#{room}')>join</button></li>``` : \n  - ```<li>``` 태그는 리스트 항목 \n  - ${room} 은 room 변수에 저장된 현재 채팅방 이름을 html 코드에 삽입 함. \n  - joinRoom('#{room}') 이라는 함수 를 실행함 ( 아직 joinroom 함수 안만듬. )\n\n### (3) 소켓 게이트웨이에서 project/room 네임스페이스를 생성 \n> project.gateway.ts \n```ts\n// room 네임스페이스 사용하는 게이트 웨이 \n@WebSocketGateway({ namespace: 'project/room'})\nexport class RoomGateway {\n  rooms = []\n  // server instance 접근을 위한 변수 선언 \n  @WebSocketServer()\n  server: Server\n\n  // createRoom 핸들러 \n  @SubscribeMessage('createRoom')\n  handleMessage(@MessageBody() data ){\n    const { nickname, room } =data\n    this.rooms.push(room)\n    // rooms 이벤트로 채팅방 리스트 전송 \n    this.server.emit('rooms', this.rooms)\n\n  }\n}\n```\n- rooms = [] 채팅방 초기화 \n- server 변수를 통해 socket.io 서버 인스턴스에 접근해 서버의 메서드를 사용가능 \n- server.emit() 메서드를 사용 \n- 클라이언트에서 요청한 createRoom 이벤트를 처리하는 핸들러 메서드 \n- 소켓은 따로 사용하지 않았으르모 data 만 잇음.  => MessageBody 데코레이터가 필요함. \n- 클라이언트 에서 받은 채팅방 정보를 미리 선언해둔 rooms 에 추가 \n\n\n### (4) 게이트 웨이 클래스는 프로바이더로 등록되어야만 사용 가능 -> project.module 추가 \n\n> project.module.ts\n```ts\n// 웹소켓 체팅을 한임포트 \nimport { ProjectGateway,RoomGateway } from './project.gateway';\n\n    providers: [\n        ProjectService, ProjectMongoRepository,\n        // 웹소켓 게이트 웨이 프로바이더 \n        ProjectGateway,\n        // 채팅방 리스트 게이트웨이 프로바이더 \n        RoomGateway,\n\n    ],\n```\n# 결과 : 채팅방 생성됨. \n<img src=\"https://blog.kakaocdn.net/dn/l8ReV/btsL39KqoLj/wl8OAzr6iqkeUieEnmwBt1/img.webp\" data-mce-src=\"https://blog.kakaocdn.net/dn/l8ReV/btsL39KqoLj/wl8OAzr6iqkeUieEnmwBt1/img.webp\" data-origin-width=\"706\" data-origin-height=\"604\" data-is-animation=\"false\" width=\"747\" height=\"639\">\n\n\n\n## 13.4.4 공지 영역과 채팅방 입장 구현 \n### (1) index.html 공지 영역 추가 \n> index.html \n```html\n        <!-- 방 만들기 버튼 -->\n        <button onclick=\"createRoom()\">방 만들기</button>\n\n        <!--채팅방 들어올 때  공지 영역 -->\n        <div>\n            <h2>notification </h2>\n            <div id=\"notice\"></div>\n        </div>\n\n```\n\n### (2) script.js에 joinRoom 과 currentRoom 세팅 \n> static/script.js\n```ts\n//------------------------ 채팅방 입장시 notice ------------------------\nlet currentRoom = ''\nsocket.on('notice', (data) => {\n    $('#notice').append(`<div>$${data.message}</div>`)\n})\nfunction joinRoom(room) {\n    // 서버측 joinRoom 이벤트 발생 : 방에 들어가면 기존에 있던 방에서는 나가야함. \n    roomSocket.emit('joinRoom', { room, nickname, toLeaveRoom: currentRoom})\n    // 현재 들어있는 방의 값 변경 \n    currentRoom = room \n}\n```\n- 서버에서 chat 네임스페이스의 notice 이벤트로 요청이 오는 경우 해당 데이터를 처리함. 받은 데이터를 id 가 notice 인 html 요소에 추가함. \n\n### (3) 클라이언트에서 보낸값 처리할 서버측 게이트 웨이 수정 , 공지사항, 채팅방 입장 기능 구현 \n> project.gateway.ts\n```ts \n/ -------------- createRoom 핸들러 --------------\n  @SubscribeMessage('createRoom')\n  handleMessage(@MessageBody() data ){\n    const { nickname, room } =data\n    // 방 생성시 이벤트 발생시켜 클라이언트에 송신 \n    this.chatGateway.server.emit('notice', {\n      message: `${nickname}님이 ${room} 방을 만들었습니다. `\n    })\n    // 채팅방 목록에 삽입 \n    this.rooms.push(room)\n    // rooms 이벤트로 채팅방 리스트 전송 \n    this.server.emit('rooms', this.rooms)\n  }\n\n  // -------------- joinRoom 핸들러 --------------\n  @SubscribeMessage('joinRoom')\n  handleJoinRoom(socket: Socket, data) {\n    const { nickname, room, toLeaveRoom } = data\n    \n    // 기존방에서 퇴장 \n    socket.leave(toLeaveRoom)\n    this.chatGateway.server.emit('notice', {\n      message: `${nickname}님이 ${room} 방에 입장 했습니다. `\n    })\n    // 새로운 방 입장. \n    socket.join(room)\n  }\n```\n- 게이트웨이는 프로바이더이기때문에 게이트웨이 클래스 간에도 동일하게 주입이 가능함.이미 만들어둔 projectGateway 를 chatGate 라는 이름의 인스턴스로 생성함(생성자 사용) \n- server.emit() 을 통해 방에 공지를 함. \n- handleJoinRoom() 메서드를 만들고 joinRoom() 이벤트를 처리. \n- nickname, room(입장할 방), toLeaveRoom(퇴장할 방 ) 정보를 받음. \n\n<img src=\"https://blog.kakaocdn.net/dn/4o9dj/btsL5OdMQU4/LC7MouTLJXExaRBKSTjVRk/img.webp\" data-mce-src=\"https://blog.kakaocdn.net/dn/4o9dj/btsL5OdMQU4/LC7MouTLJXExaRBKSTjVRk/img.webp\" data-origin-width=\"1558\" data-origin-height=\"750\" data-is-animation=\"false\" width=\"746\" height=\"359\" data-mce-selected=\"1\">\n\n\n## 13.4.5 채팅방에서 대화 나누는 기능 구현 \n\n### (1) 전송 버튼 클릭시 채팅방으로 메시지가 가도록 script.js 와 RoomGateway 핸들러 함수 추가 \n> script.js \n\n```js\nfunction joinRoom(room) {\n    // 서버측 joinRoom 이벤트 발생 : 방에 들어가면 기존에 있던 방에서는 나가야함. \n    roomSocket.emit('joinRoom', { room, nickname, toLeaveRoom: currentRoom})\n    // 채팅방 이동시 기존 메시지 삭제\n    // $('#chat').html('')\n    // 현재 들어있는 방의 값 변경 \n    currentRoom = room \n}\n```\nsocket.on => roomSocket.on 으로 모두 바꿈. \n\n\n```js\n// 전송 버튼 클릭 시 입력된 글을 socket 의 message 이벤트로 보냄 \nfunction sendMessage() {\n    //join 한 룸이나 생성한 룸이 없을때 \n    if (currentRoom == '') {\n        alert(' 방을 선택해 주세요 ')\n        return\n    }\n    // message 창에 입력된 값 할당\n    const message = $('#message').val()\n    const data = { message, nickname, room: currentRoom}\n\n    $('#chat').append(`<div> 나 : ${message}</div>`)\n    roomSocket.emit('message',data)\n\n    // 채팅 소켓의 message 로 방출 \n    // socket.emit('message', {message, nickname})\n    \n    $('#message').val('') // 입력창 비우기\n    return false\n}\n```\n\n### (2)  gateway 수정 \n```ts\n  // -------------- 채팅방 조인후 message 전송 click 시 핸들러 --------------\n  @SubscribeMessage('message')\n  handleMessageToRoom(socket: Socket, data) {\n    const { nickname, room, message } = data\n    console.log(data)\n    // 나 이외에 사람에게 데이터 전송 \n    socket.broadcast.to(room).emit('message', {\n      message: `${nickname} : ${message}`\n    })\n    console.log(`${message}`)\n  }\n\n```\n\n\n1. 처음 접속한사람에게는 기존의 채팅방 목록이 보이지않아서 무조건 방을 생성해야 방 목록을 확인 할 수 있음. \n2.  채팅방을 이동하는순간 기존의 채팅방에서 나누었던 대화가 다사라져서 다시 기존채팅방으로 이동하면 무슨대화를했는지 알수가 없음.\n3. 기존방에 처음 들어가는사람에게 기존 채팅 메시지가 전부 오른쪽에 나타남. \n> userMap 을통해 해결 \n\n\n<img src=\"https://blog.kakaocdn.net/dn/qXVoy/btsL4wyxwda/a5IzEpx3v1eh9jDoTla400/img.gif\" data-mce-src=\"https://blog.kakaocdn.net/dn/qXVoy/btsL4wyxwda/a5IzEpx3v1eh9jDoTla400/img.gif\" data-origin-width=\"1690\" data-origin-height=\"754\" data-is-animation=\"true\" width=\"813\" height=\"363\">\n\n\n\n여기까지 하고 AWS 에 테스트 서버 올린뒤에 docker 로 react 시작. "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                ""
            ],
            "outputs": []
        }
    ]
}